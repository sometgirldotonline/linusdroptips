APPVERSION = "0.3.6"
# Debug logging was added by Github Copilot
# yes this is literally the Goblintasks source code :sob:
from flask import (
    Flask,
    current_app,
    redirect,
    url_for,
    render_template,
    g,
    make_response,
    request,
    jsonify,
    session,
    send_file
)
import shutil
import jinja2
import os
import sqlite3
import json
import datetime, time
import secrets
import hashlib
import hmac
import psutil
from dotenv import load_dotenv
from flask_dance.contrib.github import make_github_blueprint, github
import requests
from requests.auth import HTTPBasicAuth
startupTimeStamp = time.time()
load_dotenv()
app = Flask(__name__)
from collections import deque
# ensure datadir exists
if not os.path.exists(
    os.path.join(os.path.dirname(os.path.realpath(__file__)), "appdata.sqlite")
):
    print("Setting up datadir")
    shutil.copytree(
        os.path.join(os.path.dirname(os.path.realpath(__file__)), "template-appdata.sqlite"),
        os.path.join(os.path.dirname(os.path.realpath(__file__)), "appdata.sqlite"),
    )

# fix reverse proxies
from werkzeug.middleware.proxy_fix import ProxyFix

app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)

app.config.from_mapping({"DEBUG": True})
# thing for reqs per sec calc
rpsTimestamps = deque(maxlen=1000)


@app.before_request
def track_request():
    rpsTimestamps.append(time.time())

def requests_per_second():
    now = time.time()
    # only count requests in the last second
    recent = [t for t in rpsTimestamps if now - t <= 1]
    return len(recent)

# done by chatGPT
def revoke_github_token(user_token):
    client_id = os.getenv("githubClientID")
    client_secret = os.getenv("githubClientSecret")

    url = f"https://api.github.com/applications/{client_id}/grant"
    headers = {
        "Accept": "application/vnd.github+json",
        "X-GitHub-Api-Version": "2022-11-28",
    }
    data = {"access_token": user_token}

    resp = requests.delete(
        url, auth=HTTPBasicAuth(client_id, client_secret), headers=headers, json=data
    )
    return resp.status_code, resp.text


# generated by copilot
def generate_deletion_token(user_id):
    """Generate a secure, time-limited token for account deletion"""
    timestamp = str(int(time.time()))
    secret_key = os.getenv("flaskDanceSecret")  # Use your existing secret

    # Create payload: user_id + timestamp
    payload = f"{user_id}:{timestamp}"

    # Create HMAC signature
    signature = hmac.new(
        secret_key.encode(), payload.encode(), hashlib.sha256
    ).hexdigest()

    # Combine payload and signature
    token = f"{payload}:{signature}"
    return token


def validate_deletion_token(token, user_id, max_age=300):  # 5 minutes
    """Validate the deletion token"""
    try:
        parts = token.split(":")
        if len(parts) != 3:
            return False

        token_user_id, timestamp, signature = parts

        # Check if user ID matches
        if int(token_user_id) != user_id:
            return False

        # Check if token is not expired
        token_time = int(timestamp)
        if time.time() - token_time > max_age:
            return False

        # Verify signature
        secret_key = os.getenv("flaskDanceSecret")
        expected_payload = f"{token_user_id}:{timestamp}"
        expected_signature = hmac.new(
            secret_key.encode(), expected_payload.encode(), hashlib.sha256
        ).hexdigest()

        return hmac.compare_digest(signature, expected_signature)

    except (ValueError, TypeError):
        return False


def get_db():
    if "db" not in g:
        if "github_id" not in session:
            return None
        user_db_path = os.path.join(
            os.path.dirname(os.path.realpath(__file__)),
            os.getenv("dataDir"),
            "userdata",
            f"user_{session['github_id']}.sqlite",
        )
        template_path = os.path.join(
            os.path.dirname(os.path.realpath(__file__)),
            os.getenv("dataDir"),
            f"user_template.sqlite",
        )
        if not os.path.exists(user_db_path):
            if os.path.exists(template_path):
                shutil.copy2(template_path, user_db_path)
            else:
                raise FileNotFoundError("Template file missing!")
        g.db = sqlite3.connect(user_db_path)
        g.db.row_factory = sqlite3.Row
    return g.db


@app.teardown_appcontext
def close_db(error):
    db = g.pop("db", None)
    if db is not None:
        db.close()


app.secret_key = os.getenv("flaskDanceSecret")
ghblueprint = make_github_blueprint(
    client_id=os.getenv("githubClientID"),
    client_secret=os.getenv("githubClientSecret"),
)
# custom filter (was written by GPT.)
@app.template_filter()
def timestamp_to_time(value, thing):
    if isinstance(value, jinja2.runtime.Undefined) or value is None:
        return None
    return datetime.datetime.fromtimestamp(value).strftime(thing)


app.register_blueprint(ghblueprint, url_prefix="/login")

def generateUpdates(state,updateTasks=True, updates=[]):
    db = get_db()
    cur = db.execute(
        "SELECT COALESCE(SUM(transactionCost), 0) AS total_value FROM transactions;"
    )
    totalValue = cur.fetchone()['total_value']
    if updateTasks:
        cur = db.execute("SELECT * FROM tasks")
        res = cur.fetchall()
    data = {
        "state": state,
        "pageUpdates": [
            {"action": "innerText",
             "selector": "#coinsBalanceValue",
             "value": totalValue}
        ]
    }
    data["pageUpdates"]+=updates
    if updateTasks:
        data["pageUpdates"]+=[            {
                "action": "innerHTML",
                "selector": "ul.tasksList",
                "value":render_template("tasksCard.html", tasks=res)
            }]
    return data


@app.route("/logout", methods=["GET"])
def logout():
    session.clear()
    res = make_response("Logged Out.")
    res.set_cookie("session", "", max_age=0)
    return res


@app.route("/", methods=["GET"])
def index():
    if not github.authorized:
        return redirect(url_for("github.login"))
    if "github_id" not in session:
        resp = github.get("/user")
        assert resp.ok
        user_info = resp.json()
        session["github_id"] = user_info["id"]
        session["github_login"] = user_info["login"]
    db = get_db()
    cur = db.cursor()
    cur.execute(f"PRAGMA table_info(tasks);")
    columns = [info[1] for info in cur.fetchall()]

    if "description" not in columns:
        cur.execute(f"ALTER TABLE tasks ADD COLUMN description TEXT")
        db.commit()
        
    # this be the old way
    # cur = db.execute(
    #     "SELECT userCoins FROM users WHERE userid = ?", (session["github_id"],)
    # )
    # data = cur.fetchall()
    usercoins = 0
    cur = db.execute(
        "SELECT COALESCE(SUM(transactionCost), 0) AS total_value FROM transactions;"
    )
    res = cur.fetchone()
    username = session["github_login"]
    cur = db.execute("SELECT * FROM tasks")
    if "analNoticeSeen" not in session:
        session["analNoticeSeen"] = False
    if "enableAnal" not in session:
        session["enableAnal"] = False
    dnt = request.headers.get("DNT") == "1"
    gpc = request.headers.get("Sec-GPC") == "1"
    if dnt or (gpc and "modifiedInSettings" not in session):
        session["enableAnal"] = False
        session["analNoticeSeen"] = True
    theme = ""
    if "theme" in session:
        theme = session["theme"]
    else:
        session["theme"] = "default"
    return render_template(
        "app.html",
        username=username,
        usercoins=res["total_value"] + usercoins,
        tasks=cur.fetchall(),
        showAnayliticsNotice=not session["analNoticeSeen"],
        enableAnal=session["enableAnal"],
        theme=theme,
        host=os.getenv("APPHOST"),
        session=session,
    )


@app.route("/api", methods=["GET"])
def notforyou():
    return "no"


@app.route("/api/updateTaskState", methods=["POST"])
def uts():
    state = "1$it probably worked idk"
    selector = "ul.tasksList"
    if "id" in request.form and "state" in request.form:
        # Debug logging
        print(f"DEBUG: Received id={request.form['id']}, state={request.form['state']}")
        if not github.authorized:
            return redirect(url_for("github.login"))
        db = get_db()
        cur = db.execute(
            "SELECT * FROM tasks WHERE taskID = ?",
            (
                request.form["id"],
            ),
        )
        thistask = cur.fetchall()
        if len(thistask) == 1:
            # Debug: Show what we're about to update
            new_completion_value = 1 if request.form["state"] == "1" else 0
            print(
                f"DEBUG: Updating taskID {request.form['id']} to completion {new_completion_value}"
            )
            # this sql statement was adjusted by chat GPT, i have no clue what im doing with SQL.
            cur = db.execute(
                """
            UPDATE tasks
            SET taskCompletion = ?
            WHERE ownerID = ? AND taskID = ?;
            """,
                (
                    new_completion_value,
                    session["github_id"],
                    request.form["id"],
                ),
            )
            if new_completion_value == 1:
                db.execute("""INSERT INTO transactions (
                             relatedTaskID,
                             transactionCost,
                             transactionType,
                             transactionName
                         )
                         VALUES (
                             ?,
                             ?,
                             2,
                             ?
                         );
""",(request.form["id"],thistask[0]['taskValue'], f"Completed task: {thistask[0]['taskName']}", ))
            elif new_completion_value == 0:
                db.execute("DELETE FROM transactions WHERE relatedTaskID = ?", (request.form["id"],))
            db.commit()

            # Debug: Verify the update worked
            cur = db.execute(
                "SELECT taskCompletion FROM tasks WHERE ownerID = ? and taskID = ?",
                (
                    session["github_id"],
                    request.form["id"],
                ),
            )
            updated_result = cur.fetchall()
            print(
                f"DEBUG: After update, taskCompletion = {updated_result[0]['taskCompletion'] if updated_result else 'NOT FOUND'}"
            )

        elif len(res) == 0:
            state = "eNotFound"
        elif len(res) > 1:
            state = "eTooManyFound"
        # tasks = []
        cur = db.execute(
            "SELECT * FROM tasks WHERE ownerID = ?", (session["github_id"],)
        )
        res = cur.fetchall()
        for task in res:
            print(dict(task))
        # for task in res:
        #     tasks.append(json.dumps(dict(task)))
        # sql by chatGPT again, i hate working with SQL but it made the most sense for this
        # cur = db.execute(
        #     "SELECT COALESCE(SUM(taskValue), 0) AS total_value FROM tasks WHERE ownerID = ? and taskCompletion = 1;",
        #     (session["github_id"],),
        # )
        if new_completion_value == 1 and session.get("sendMessageOnComplete") and session.get("minMsgCoins") and thistask[0]["taskValue"] >= session.get("minMsgCoins", 0):
            # Slack integration removed: previously sent a congratulatory message via Slack.
            # If you'd like a replacement notification, implement it here.
            pass
        return generateUpdates(state)
    else:
        return generateUpdates(f"0${state}")

@app.route("/api/getPage", methods=["POST"])
def getPage():
    if "page" in request.form:
        if request.form["page"] == "settings":
            return generateUpdates("1$success", updates=[{
                "action": "innerHTML",
                "selector": "section.maincontent",
                "value":render_template("settingsPage.html", theme=session["theme"], home=os.getenv("APPHOST"), sites=get_db().execute("SELECT * FROM blockedsites").fetchall())
            }],updateTasks=False)
        elif request.form["page"] == "home":
            db = get_db()
            cur = db.execute("SELECT * FROM tasks")
            return generateUpdates("1$success", updates=[{
                "action": "innerHTML",
                "selector": "section.maincontent",
                "value":render_template("homePage.html",tasks=cur.fetchall())
            }],updateTasks=False)
        elif request.form["page"] == "transactions":
            db = get_db()
            cur = db.execute("SELECT * FROM transactions")
            return generateUpdates("1$success", updates=[{
                "action": "innerHTML",
                "selector": "section.maincontent",
                "value":render_template("transPage.html",transactions=cur.fetchall())
            }],updateTasks=False)
    else:
        return generateUpdates(f"0$noPageID")


@app.route("/api/setTheme", methods=["POST"])
def setTheme():
    if "theme" in request.form:
            session["theme"] = request.form["theme"]
            return generateUpdates("1$success", updates=[{
                "action": "setAttribute",
                "selector": "html",
                "value":{"name":"class", "value":request.form["theme"]}
            }],updateTasks=False)
    else:
        return generateUpdates(f"0$noThemeName")



@app.route("/api/addTask", methods=["POST"])
def addTask():
    state = "1$it probably worked idk"
    selector = "ul.tasksList"
    if (
        "dueBy" in request.form
        and "taskValue" in request.form
        and "taskName" in request.form
    ):
        if not github.authorized:
            return redirect(url_for("github.login"))

        # Validate and convert inputs
        try:
            task_value = int(request.form["taskValue"])
            due_raw = request.form["dueBy"].strip()
            if due_raw == "" or due_raw.lower() == "nan":
                due_by = -1
            else:
                due_by = int(due_raw)
            task_name = request.form["taskName"].strip()

            if not task_name:
                state = "eEmptyTaskName"
                return generateUpdates(f"0${state}")

        except ValueError:
            state = "eInvalidNumber"
            return generateUpdates(f"0${state}")

        db = get_db()
        try:
            cur = db.execute(
                """
INSERT INTO tasks (
                        completionDate,
                        creationDate,
                        dueBy,
                        taskCompletion,
                        taskValue,
                        taskName,
                        ownerID,
                        description
                    )
                    VALUES (
                        -1,
                        ?,
                        ?,
                        0,
                        ?,
                        ?,
                        ?,
                        ?
                    );
            """,
                (
                    time.time(),
                    due_by,
                    task_value,
                    task_name,
                    session["github_id"],
                    request.form["description"]
                ),
            )
            db.commit()
        except sqlite3.Error:
            state = "eDatabaseError"
            return generateUpdates(f"0${state}")
        except sqlite3.Error:
            state = "eDatabaseError"
            return generateUpdates(f"0${state}")

        return generateUpdates(state)

    else:
        return generateUpdates(state)

@app.route("/api/editTaskDialog", methods=["POST"])
def editTask():
    if "id" in request.form:
        db = get_db();
        cur = db.execute("SELECT * FROM tasks WHERE taskID = ?",
                (
                    int(request.form["id"]),
                ),
            )
        return generateUpdates("1$success", updates=[{
            "action": "innerHTML",
            "selector": "dialog",
            "value":render_template("editTaskCard.html", task=cur.fetchone())
        },{
                "action": "setAttribute",
                "selector": "dialog",
                "value":{"name":"open", "value":"open"}
            }],updateTasks=False)
    else:
        return generateUpdates(f"0$noTaskID")


@app.route("/api/addSiteDialog", methods=["POST"])
def addSiteDialog():
    return generateUpdates("1$success", updates=[{
        "action": "innerHTML",
        "selector": "dialog",
        "value":render_template("modifyOrAddBlockedSite.html", site={"domain": "", "unblockCost": "30"},action="new")
    },{
            "action": "setAttribute",
            "selector": "dialog",
            "value":{"name":"open", "value":"open"}
        }],updateTasks=False)

@app.route("/api/addTaskDialog", methods=["POST"])
def addTaskDialog():
    return generateUpdates("1$success", updates=[{
        "action": "innerHTML",
        "selector": "dialog",
        "value":render_template("addTaskModal.html")
    },{
            "action": "setAttribute",
            "selector": "dialog",
            "value":{"name":"open", "value":"open"}
        }],updateTasks=False)


@app.route("/api/editSiteDialog", methods=["POST"])
def editSiteDialog():
    if "id" in request.form:
        db = get_db();
        cur = db.execute("SELECT * FROM blockedsites WHERE id = ?",
                (
                    int(request.form["id"]),
                ),
            )
        return generateUpdates("1$success", updates=[{
            "action": "innerHTML",
            "selector": "dialog",
            "value":render_template("modifyOrAddBlockedSite.html", site=cur.fetchone(),action="modify")
        },{
                "action": "setAttribute",
                "selector": "dialog",
                "value":{"name":"open", "value":"open"}
            }],updateTasks=False)
    else:
        return generateUpdates(f"0$noTaskID")


@app.route("/api/aboutDialog", methods=["POST"])
def abtdiag():
        return generateUpdates("1$success", updates=[{
            "action": "innerHTML",
            "selector": "dialog",
            "value":f"""<section class="card"><span class="title">About</span>
<p>Version: {APPVERSION}</p>
<form method="dialog"><button type="submit" class="fancyfancyfancy">Close</button></form>"""
        },{
                "action": "setAttribute",
                "selector": "dialog",
                "value":{"name":"open", "value":"open"}
            }],updateTasks=False)
@app.route("/api/editTask", methods=["POST"])
def etphonehome():
    state = "1$it probably worked idk"
    if (
        "id" in request.form and
        "dueBy" in request.form
        and "taskValue" in request.form
        and "taskName" in request.form
    ):
        if not github.authorized:
            return redirect(url_for("github.login"))

        # Validate and convert inputs
        try:
            task_value = int(request.form["taskValue"])
            due_raw = request.form["dueBy"].strip()
            if due_raw == "" or due_raw.lower() == "nan":
                due_by = -1
            else:
                due_by = int(due_raw)
            task_name = request.form["taskName"].strip()

            if not task_name:
                state = "eEmptyTaskName"
                return generateUpdates(f"0${state}")

        except ValueError:
            state = "eInvalidNumber"
            return generateUpdates(f"0${state}")

        db = get_db()
        try:
            cur = db.execute(
                """
            UPDATE tasks
            SET taskName = ?, taskValue = ?, dueBy = ?, description = ?
            WHERE ownerID = ? AND taskID = ?;
            """,
                (
                    task_name,
                    task_value,
                    due_by,
                    request.form["description"].strip(),
                    session["github_id"],
                    int(request.form["id"]),
                ),
            )
            db.commit()
        except sqlite3.Error:
            state = "eDatabaseError"
            return generateUpdates(f"0${state}")

        return generateUpdates(state, updates=[{
            "action": "innerHTML",
            "selector": "dialog",
            "value":""
        },{
                "action": "setAttribute",
                "selector": "dialog",
                "value":{"name":"open", "value":"pleaseRemoveThisAttrDaddyUWU"}
            }])

    else:
        return generateUpdates(state)

@app.route("/api/editSite", methods=["POST"])
def etdontphoneomepleasepleasepleaseplease():
    state = "1$it probably worked idk"
    if (
        "id" in request.form and
        "domain" in request.form
        and "unblockCost" in request.form
    ):
        if not github.authorized:
            return redirect(url_for("github.login"))

        # Validate and convert inputs
        try:
            unblockCost = int(request.form["unblockCost"])
            domain = request.form["domain"].strip()

            if not domain:
                state = "eEmptyDomainName"
                return generateUpdates(f"0${state}", updateTasks=False)

        except ValueError:
            state = "eInvalidNumber"
            return generateUpdates(f"0${state}", updateTasks=False)

        db = get_db()
        try:
            cur = db.execute(
                """
            UPDATE blockedsites
            SET domain = ?, unblockCost = ? WHERE id = ?;
            """,
                (
                    domain,
                    unblockCost,
                    int(request.form["id"]),
                ),
            )
            db.commit()
        except sqlite3.Error:
            state = "eDatabaseError"
            return generateUpdates(f"0${state}", updateTasks=False)

        return generateUpdates(state, updates=[{
            "action": "innerHTML",
            "selector": "dialog",
            "value":""
        },{
                "action": "setAttribute",
                "selector": "dialog",
                "value":{"name":"open", "value":"pleaseRemoveThisAttrDaddyUWU"}
            }, {
                "action" : "innerHTML",
                "selector": ".sitesList",
                "value": render_template("blockedSitesCard.html", sites=get_db().execute("SELECT * FROM blockedsites").fetchall())
            }], updateTasks=False)

    else:
        return generateUpdates(state)

@app.route("/api/addSite", methods=["POST"])
def addSite():
    state = "1$it probably worked idk"
    if (
        "domain" in request.form
        and "unblockCost" in request.form
    ):
        if not github.authorized:
            return redirect(url_for("github.login"))

        # Validate and convert inputs
        try:
            unblockCost = int(request.form["unblockCost"])
            domain = request.form["domain"].strip()

            if not domain:
                state = "eEmptyDomainName"
                return generateUpdates(f"0${state}", updateTasks=False)

        except ValueError:
            state = "eInvalidNumber"
            return generateUpdates(f"0${state}", updateTasks=False)

        db = get_db()
        try:
            cur = db.execute(
                """
            INSERT INTO blockedsites (domain, unblockCost) VALUES (?, ?);
            """,
                (
                    domain,
                    unblockCost,
                ),
            )
            db.commit()
        except sqlite3.Error:
            state = "eDatabaseError"
            return generateUpdates(f"0${state}", updateTasks=False)

        return generateUpdates(state, updates=[{
            "action": "innerHTML",
            "selector": "dialog",
            "value":""
        },{
                "action": "setAttribute",
                "selector": "dialog",
                "value":{"name":"open", "value":"pleaseRemoveThisAttrDaddyUWU"}
            }, {
                "action" : "innerHTML",
                "selector": ".sitesList",
                "value": render_template("blockedSitesCard.html", sites=get_db().execute("SELECT * FROM blockedsites").fetchall())
            }], updateTasks=False)

    else:
        return generateUpdates(state)


@app.route("/api/deleteTask", methods=["POST"])
def deleteTask():
    state = "1$it probably worked idk"
    selector = "ul.tasksList"
    if "id" in request.form:
        if not github.authorized:
            return redirect(url_for("github.login"))

        # Validate and convert inputs
        try:
            task_id = int(request.form["id"])

            if not task_id:
                state = "eNoID"
                return generateUpdates(f"0${state}")

        except ValueError:
            state = "eVerror"
            return generateUpdates(f"0${state}")

        db = get_db()
        try:
            # cur = db.execute(
            #     "SELECT * FROM tasks WHERE taskID = ? AND ownerID = ?",
            #     (
            #         request.form["id"],
            #         session["github_id"],
            #     ),
            # )
            # # dumb name, just means store the value properly, into the users coin balance
            # task = cur.fetchone()
            # commitTaskEvasion = task["taskCompletion"] == 1
            cur = db.execute(
                "DELETE FROM tasks WHERE taskID = ?",
                (
                    int(request.form["id"]),
                ),
            )
            # if commitTaskEvasion:
            #     cur = db.execute(
            #         "UPDATE users SET userCoins = userCoins + ? WHERE userID = ?;",
            #         (
            #             task["taskValue"],
            #             session["github_id"],
            #         ),
            #     )
            db.commit()
        except sqlite3.Error:
            state = "eDatabaseError"
            return generateUpdates(f"0${state}")
        return generateUpdates(state)

    else:
        return generateUpdates(state)


@app.route("/api/removeSite", methods=["POST"])
def removeSite():
    state = "1$it probably worked idk"
    if "id" in request.form:
        if not github.authorized:
            return redirect(url_for("github.login"))

        # Validate and convert inputs
        try:
            task_id = int(request.form["id"])

            if not task_id:
                state = "eNoID"
                return generateUpdates(f"0${state}", updateTasks=False)

        except ValueError:
            state = "eVerror"
            return generateUpdates(f"0${state}",updateTasks=False)

        db = get_db()
        try:
            cur = db.execute(
                "DELETE FROM blockedsites WHERE id = ?",
                (
                    int(request.form["id"]),
                ),
            )
            db.commit()
        except sqlite3.Error:
            state = "eDatabaseError"
            return generateUpdates(f"0${state}",updateTasks=False)
        return generateUpdates(state, updates=[{"action": "innerHTML", "selector": ".sitesList", "value": render_template("blockedSitesCard.html", sites=get_db().execute("SELECT * FROM blockedsites").fetchall())}], updateTasks=False)

    else:
        return generateUpdates(state)


@app.route("/api/deleteaccount", methods=["GET"])
def goodbyecruelworld():
    # First check: Referer protection against prank links
    referer = request.headers.get("Referer")
    origin = request.headers.get("Origin")
    allowed_origins = [os.getenv("APPHOST")]
    if origin not in allowed_origins and (
        not referer or not any(referer.startswith(o) for o in allowed_origins)
    ):
        return """
<h1>EEK!</h1>
You must have clicked a "prank" link or something! It tried to DELETE YOUR ACCOUNT :sob:<br>
Don't worry, your data is safe :D <br>
If you did request account deletion, you might want to download your data<br>
Once downloaded, you can browse your user data using any SQLite viewer tool like <a href="https://sqliteviewer.app/">SQLiteViewer.app (runs entirely in your browser, your data is never sent anywhere, unaffiliated though) </a>
<h1><a href="/api/getUserData">Click to download your data</a></h1>
<h1><a href="/">Take me to linus drop tips</a></h1>
<small><i>you should probably smite the person that sent you this link, they're evil lmao</i></small>
    """

    # Must be authenticated
    if not github.authorized:
        return redirect(url_for("github.login"))

    # Generate secure deletion token
    if "github_id" not in session:
        resp = github.get("/user")
        assert resp.ok
        user_info = resp.json()
        session["github_id"] = user_info["id"]
        session["github_login"] = user_info["login"]

    deletion_token = generate_deletion_token(session["github_id"])

    return f"""
<center>
<h1>Are you sure :3c?</h1>
<i>You're about to delete your account</i><br><br>
<strong>This action cannot be undone!</strong><br><br>
<a href="/api/deleteaccountforreals?token={deletion_token}" 
   onclick="return confirm('Are you ABSOLUTELY sure? This will permanently delete all your tasks and data!')">
   Yes, delete my account permanently
</a><br><br>
<a href="/">No, take me back to safety</a><br><br>
<small><i>This deletion link expires in 5 minutes for security.</i></small>
</center>
"""

@app.route("/api/generateShortLivedVerytrustableToken")
def genSLVT():
    if not github.authorized:
        return redirect(url_for("github.login"))
    return {"token":generate_deletion_token(session["github_id"])}
    


@app.route("/api/deleteaccountforreals", methods=["GET"])
def actuallydeleteaccount():
    # Must be authenticated
    if not github.authorized:
        return redirect(url_for("github.login"))

    # Get token from URL
    token = request.args.get("token")
    if not token:
        return (
            """
<center>
<h1>security sillies</h1>
<p>ur token is missing, not ur fault probably, just start it again.</p>
<a href="/api/deleteaccount">go again</a> | 
<a href="/">Go home</a>
</center>
""",
            400,
        )

    # Validate token
    if not validate_deletion_token(token, session["github_id"]):
        return (
            """
<center>
<h1>oops</h1>
<p>the security token is invalid!</p>
<ul style="text-align: left; max-width: 400px;">
<li>it expired (links expire after 5 minutes)</li>
<li>it was tampered with</li>
<li>we dont think you are the person who requested deletion</li>
</ul>
<a href="/api/deleteaccount">Restart process</a> | 
<a href="/">Go home</a>
</center>
""",
            403,
        )

    # Additional confirmation using POST method for the actual deletion
    return f"""
<center>
<h1>FINAL WARNING</h1>
<p><strong>youre about to permenantly delete your account</strong></p>
<p>say your goodbyes to:</p>
<ul style="text-align: left; max-width: 300px;">
<li>tasks</li>
<li>coins</li>
<li>everything else</li>
</ul>
<br>
<form method="POST" action="/api/executeaccountdeletion" onsubmit="return confirm('are you really sure? this is ur last chance, and your data cannot be recovered (we dont store it)')">
    <input type="hidden" name="token" value="{token}">
    <input type="hidden" name="csrf_token" value="{secrets.token_hex(16)}">
    <button type="submit" style="background: red; color: white; padding: 10px 20px; border: none; cursor: pointer;">
        yes i am very sure
    </button>
</form>
<br>
<a href="/">no i wanna stay!</a>
</center>
"""


@app.route("/api/executeaccountdeletion", methods=["POST"])
def executeaccountdeletion():
    if not github.authorized:
        return redirect(url_for("github.login"))
    token = request.form.get("token")
    if not token or not validate_deletion_token(token, session["github_id"]):
        return "oops, try again (security issues)", 403
    try:
        revoke_github_token(ghblueprint.token["access_token"])
        os.remove(os.path.join(
            os.path.dirname(os.path.realpath(__file__)),
            os.getenv("dataDir"),
            "userdata",
            f"user_{session['github_id']}.sqlite",
        ))
        logout()
        session.clear()

        return """
<center>
<h1>byee :3c</h1>
<p>its all gone, no we cant recover it, dont ask. we never retain your data</p>
</center>
"""

    except Exception as e:
        print(e)
        return f"Deletion failed: {str(e)}", 500

@app.route("/api/getUserData", methods=["GET"])
def getUserData():
    if not github.authorized:
        return redirect(url_for("github.login"))
    try:
        return send_file(os.path.join(
            os.path.dirname(os.path.realpath(__file__)),
            os.getenv("dataDir"),
            "userdata",
            f"user_{session['github_id']}.sqlite",
        ))
    except Exception as e:
        print(e)
        return f"Download failed: {str(e)}", 500


@app.route("/api/configureAnaylitics", methods=["POST"])
def configureAnaylitics():
    if not github.authorized:
        return redirect(url_for("github.login"))
    print(request.form["state"])
    if not session["analNoticeSeen"]:
        session["analNoticeSeen"] = True
    if request.form["modifiedInSettings"] == "true":
        session["modifiedInSettings"] = True
    if request.form["state"] == "true":
        print("enabling anal")
        session["enableAnal"] = True
        return generateUpdates("1$enabled")
    elif request.form["state"] == "false":
        print("disabling anal")
        session["enableAnal"] = False
        return generateUpdates("1$disabled")

@app.route("/api/getUnblockedSitesNow")
def GUSN():
    if not github.authorized:
        return redirect(url_for("github.login"))
    db = get_db()
    cur = db.execute(f"""SELECT *
FROM transactions
WHERE transactionType = 1
  AND transactionStamp >= ? - 900
  AND transactionName LIKE 'Unblock%';
""", (time.time(),))
    unblockedDomains = []
    for row in cur:
        unblockedDomains.append(row["transactionName"].split(": ")[1])
    print(unblockedDomains)
    return unblockedDomains
@app.route("/api/purchaseSiteUnblock")
def purchaseSiteUnblock():
    if not github.authorized:
        return redirect(url_for("github.login"))
    if "token" in request.args and "domain" in request.args:
        if validate_deletion_token(request.args["token"], session["github_id"]):
            db = get_db()
            # Get the unblock cost first
            site_data = db.execute('SELECT unblockCost FROM blockedsites WHERE domain = ?', (request.args["domain"],)).fetchone()
            if db.execute("SELECT COALESCE(SUM(transactionCost), 0) AS total_value FROM transactions;").fetchone()["total_value"] - site_data["unblockCost"] < 0:
                return {"success":0, "why":"Ooops, you don't have enough money for this, do your work, and try again."}
            if site_data:
                unblock_cost = -site_data["unblockCost"]  # Negative because it's a cost
                db.execute("""
                    INSERT INTO transactions (
                        transactionStamp,
                        transactionCost,
                        transactionType,
                        transactionName
                    )
                    VALUES (?, ?, ?, ?)
                """, (time.time(), unblock_cost, 1, f'Unblock: {request.args["domain"]}'))
                db.commit()
            return {"success":1}
        else:
            return {"success":0,"why":"invalidToken"}
    return {"success":0,"why":"missParam"}
  
@app.route("/api/makePurchase")
def makePurchase():
    if not github.authorized:
        return redirect(url_for("github.login"))
    if "token" in request.args and "name" in request.args and "type" in request.args and "cost" in request.args:
        if request.args["type"] == 2:
            return {"success": 0, "why": "You cannot earn coins from a task without completing it. Just use the task completion api."}
        if validate_deletion_token(request.args["token"], session["github_id"]):
            db = get_db()
            # Get the unblock cost first
            if db.execute("SELECT COALESCE(SUM(transactionCost), 0) AS total_value FROM transactions;").fetchone()["total_value"] + int(request.args["cost"]) < 0:
                return {"success":0, "why":"Ooops, you don't have enough money for this."}
            db.execute("""
                    INSERT INTO transactions (
                        transactionStamp,
                        transactionCost,
                        transactionType,
                        transactionName
                    )
                    VALUES (?, ?, ?, ?)
            """, (time.time(), int(request.args["cost"]), int(request.args["type"]), request.args["name"]))
            db.commit()
            return {"success":1}
        else:
            return {"success":0,"why":"invalidToken"}
    return {"success":0,"why":"missParam"}
        

@app.route("/api/getBlockedSiteData")
def gbsd():
    if not github.authorized:
        return redirect(url_for("github.login"))
    cur = get_db().execute("SELECT * FROM blockedsites")
    columns = [column[0] for column in cur.description]
    rows = cur.fetchall()
    data = []
    for row in rows:
        row_dict = {columns[i]: row[i] for i in range(len(columns))}
        data.append(row_dict)
    return data
@app.route("/api/health", methods=["GET"])
def healthAPI():
    ghApiStat = "unknown"
    try:
        r = requests.get("https://api.github.com", timeout=5)
        if r.status_code == 200:
            ghApiStat = "OK200"
        else:
            ghApiStat = f"CODE{r.status_code}"
    except requests.RequestException:
        ghApiStat = "unreachable"
    duTotal, duUsed, duFree = shutil.disk_usage("/")
    return {
        "uptime": time.time() - startupTimeStamp,
        "duPcent": (duUsed / duTotal) * 100,
        "githubAPI": ghApiStat,
        "cpuUsage": psutil.cpu_percent(interval=1),
        "appCPUusage": psutil.Process().cpu_percent(interval=1),
        "reqPerSec": format(requests_per_second(), ".2f")
    }   

@app.route("/api/setSessionData")
def sSD():
    if "key" in request.args and "value" in request.args:
        session[request.args["key"]] = request.args["value"]
        return session[request.args["key"]]
@app.route("/api/getSessionData")
def gSD():
    if "key" in request.args:
        return session[request.args["key"]]
    

@app.route("/api/setMessageCompletion")
def setMessageCompletion():
    params = {"sendMessageOnComplete": request.args.get("sendMessageOnComplete", "off"), "minMsgCoins": request.args.get("minMsgCoins", 10)}
    if "sendMessageOnComplete" in params and "minMsgCoins" in params:
        session["sendMessageOnComplete"] = params["sendMessageOnComplete"].lower() == "on"
        session["minMsgCoins"] = int(params["minMsgCoins"])
        return redirect(url_for("index"))
    return "missingParams", 400
if __name__ == "__main__":
    if os.getenv("PROTOCOL") == "HTTPS": 
        app.run(port=os.getenv("port"), ssl_context=(os.getenv("certfile"), os.getenv("keyfile")))
    elif os.getenv("PROTOCOL") == "HTTP": 
        app.run(port=os.getenv("port"))
    